{"repo": "amoffat/sh", "pull_number": 744, "instance_id": "amoffat__sh-744", "issue_numbers": [743], "base_commit": "b658ce261b56c02cb8635416d310ca8f30f4dc90", "patch": "diff --git a/sh.py b/sh.py\nindex d52d8b60..b02d6e16 100644\n--- a/sh.py\n+++ b/sh.py\n@@ -889,7 +889,10 @@ def __next__(self):\n     def __await__(self):\n         async def wait_for_completion():\n             await self.aio_output_complete.wait()\n-            return str(self)\n+            if self.call_args[\"return_cmd\"]:\n+                return self\n+            else:\n+                return str(self)\n \n         return wait_for_completion().__await__()\n \n", "test_patch": "diff --git a/tests/sh_test.py b/tests/sh_test.py\nindex 8a87fd69..0fe03111 100644\n--- a/tests/sh_test.py\n+++ b/tests/sh_test.py\n@@ -1732,7 +1732,7 @@ def test_async_exc(self):\n         py = create_tmp_test(\"\"\"exit(34)\"\"\")\n \n         async def producer():\n-            await python(py.name, _async=True)\n+            await python(py.name, _async=True, _return_cmd=False)\n \n         self.assertRaises(sh.ErrorReturnCode_34, asyncio.run, producer())\n \n@@ -1786,6 +1786,22 @@ async def producer():\n \n         self.assertRaises(sh.ErrorReturnCode_34, asyncio.run, producer())\n \n+    def test_async_return_cmd(self):\n+        py = create_tmp_test(\n+            \"\"\"\n+import sys\n+sys.exit(0)\n+\"\"\"\n+        )\n+\n+        async def main():\n+            result = await python(py.name, _async=True, _return_cmd=True)\n+            self.assertIsInstance(result, sh.RunningCommand)\n+            result_str = await python(py.name, _async=True, _return_cmd=False)\n+            self.assertIsInstance(result_str, str)\n+\n+        asyncio.run(main())\n+\n     def test_handle_both_out_and_err(self):\n         py = create_tmp_test(\n             \"\"\"\n", "problem_statement": "Need way for await sh.command to return RunningCommand\nI'm finally porting [Carthage](https://github.com/hadron/carthage)  from sh 1.x to sh 2.x. We had our own hack to enable async for sh, and we had a lot of code that did things like\r\n```python\r\nresult = await sh.ssh(...)\r\n```\r\nAnd then for example looked at `result.stdout`.\r\nSo, part of this can be handled by setting `_return_cmd=True`, but the definition of `RunningCommand.__await__` is hard-coded to return `str(self)`.\r\nObviously, I can do something like\r\n```python\r\nresult = sh.ssh(...)\r\nawait result\r\n```\r\nBut that feels clumsy.\r\nI'd like a kwarg that returns a RunningCommand even on async await.\r\nMy preference would be to try and convince you that `_return_cmd` should affect await as well as __call__, but if you are concerned about the API instability, I'm happy with anything that I can pass into bake.\r\n\r\nThanks for your consideration.\r\n\n", "hints_text": "I think that's a reasonable request, and the way the api should work. The fact that it doesn't seems to be incorrect behavior. Do you feel comfortable making this change?\n\nYes. I'll send in a pull request tomorrow.\nThe change is trivial, learning your test system enough to propose tests\nwill take most of the time.\nBut I've been working with sh long enough I should go learn the test\nsystem anyway.\n\n\n", "all_hints_text": "I think that's a reasonable request, and the way the api should work. The fact that it doesn't seems to be incorrect behavior. Do you feel comfortable making this change?\n\nYes. I'll send in a pull request tomorrow.\nThe change is trivial, learning your test system enough to propose tests\nwill take most of the time.\nBut I've been working with sh long enough I should go learn the test\nsystem anyway.\n\n\n", "commit_urls": ["https://github.com/amoffat/sh/commit/3a9d8ce9fb88e4abbea5dbb7e84929e6f8968a63"], "created_at": "2025-01-08T22:39:32Z", "commit_url": "https://github.com/amoffat/sh/tree/b658ce261b56c02cb8635416d310ca8f30f4dc90"}
